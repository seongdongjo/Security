최초 웹은 팀 버너스 리 박사에 의해 탄생. 멀리떨어져있는 동료 연구자와 지식을 공유하기 위해 만듬<br>
그래서 초기의 웹은 단순히 텍스트로 구성되었으며, 하이퍼텍스트를 이용해 다른페이지로 이동하였다.<br>
1994~2004년까지가(텍스트+링크) 웹 1.0 시대라고 한다.<br><br>

URL에는 예약문자가 있는데 http:localhost:8080?val=test&val2=test+is<br>
여기서 ?,&,+이런게 예약문자이고 +는 공백을 의미한다. 서버에 넘어갈때는 test is 이렇게 파라미터 값으로 넘어간다.<br>

그러면 파라미터에 +같은 예약문자 자체를 못넘길까?? => 패스워드에 예약문자가 포함되어 파라미터로 던져야되는데..<br>

그때, 이제 URL인코딩을 쓴다. URL상에서 문자를 표현하는 방법으로 데이터 전송상에 손실을 막기위해서<br>
인코딩을 사용한다. 즉, 예약문자를 단순데이터로 전송이 될 수 있도록 인코딩을 한다.<br>
웹브라우저를 사용할 경우 브라우저에서 URL인코딩은 자동으로해준다.<br>

<h3>이정도는 외우자</h3>
문자    인코딩<br>
&       %26<br>
%       %25<br>
+       %2B<br>
공백    %20<br>
=       %3D<br>
#       %23<br>
'       %27<br>
?       %3F<br><br>

이런게 서버에 전달되면 알아서 각 문자로 바뀐다<br>
사용자입장에서는 어? 우리는 그냥 패스워드입력할때 특수문자 넣는데 누가 인코딩해주는거지?<br>
=>바로 웹브라우저에서 해준다. <br>
그래서 http://localhost:8080?pw=test%26%25 이렇게 나오는 것이다. <br>
<h4>즉, 클라이언트에서 서버로 갈때 인코딩을 해서 넘어간다.</h4>

HTTP프로토콜의 연결관리 방식은 크게 비지속연결과 지속연결 두가지로 나뉜다.<br>
HTTP버전에 따라 다른데, HTTP/0.9,1.0까지는 비지속연결이며, HTTP/1.0+,1.1,2.0은 지속연결이다<br>
HTTP1.0+에서 Keep-alive 커넥션을 통해 지속연결을 지원하며 HTTP/1.1부터는 명세에서 빠지고 지속연결을 기본으로한다<br>
즉, Keep-alive사용없이 모든연결을 지속연결로한다<br>

가끔 HTTP/1.1부터 keep-alive를 지원한다고 하는데 그거는 틀린것이다.<br>

---
<h4>비지속연결</h4>
초기에 HTTP에서 사용하던 방식이다.HTTP/1.0까지 사용되었다. <br>
초기웹은 단순히 문서를 전달했어서 지속연결이 필요하지않아서 한번의 요청이후 응답이 오면 끊어버렸다.<br>
하지만, 오늘날은 html뿐만아니라,js,css,png 등 많은 리소스가 필요한데 리소스요청마다 3-way hand shake를<br>
수행한다는것은 부적합한 연결방식이라는 것이다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/1.PNG" width="650" height="400" /><br><br>

---
<h4>지속연결</h4>
헤더에 "Connection: Keep-Alive"란 것이 명시가 되어있으면, 지속연결을 사용한다는 것이다.<br>
HTTP/1.0부터는 헤더에 "Connection: Keep-Alive"헤더 필요없이 기본적으로 지속연결을 한다.<br>
즉, 단 한번의 3-Way Handshake과정으로 여러번의 요청,응답을 할수 있다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/2.PNG" width="650" height="400" /><br><br>

---
<h4>HTTP메시지</h4>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/3.PNG" width="650" height="400" /><br><br>
헤더의 끝은 개행문자가 2개이다. 아래그림에 \r\n\r\n두개(개행문자)가 붙어있는걸 볼 수 있다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/4.PNG" width="650" height="400" /><br><br>
아래에 Content-Type까지가 헤더인데 두줄이 개행(\r\n\r\n)으로 띄워진걸 볼 수있다.<br>
또한, Post로 넘길때는 무조건 Content-Type: apllication/x-www-form-unlencoded 라고 있어야한다<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/5.PNG" width="650" height="400" /><br><br>
이렇게 에러페이지는 서버별로 다르기 때문에 어떤 서버를 쓰는지 확인할수있다.<br>
그래서 별도의 에러페이지를 만들어야 좋다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/6.PNG" width="650" height="400" /><br><br>

---
쿠키: 지속쿠키, 세션쿠키로 나뉜다<br>
서버에서 클라이언트로 쿠키발급 시 Set-Cookie라는 헤더에 의해 클라이언트 쿠키값이 세팅하고,<br>
해당 사이트 접근 시마다 클라이언트는 Set-cookie에 의해 세팅된값을 Cookie헤더에 세팅하여 요청메시지를 전달한다.<br><br>

즉, 클라이언트가 A사이트 접속 시 A사이트의 서버는 Set-Cookie를 세팅해서 보내준다.<br>
그러면, 클라이언트측에서는 A사이트의 쿠키값을 기록해둔다.(웹브라우저 메모리에)<br>
이렇게 세팅이되면 A사이트 접근할때마다 상태관리를 하는것이다.<br>

<h4>지속쿠키 발급과정<h4>
- 로그인 기능으로 살펴보자<br>
1. 클라이언트가 로그인을 이렇게 요청했다고 하자<br>

```
POST/login.php HTTP/1.1
Host: www.test.co.kr
Content-Type: application/x-www-form-urlencoded

id=hong123&pw=hong123!123!@
```

2. 정상로그인이라면 서버는 아래처럼 응답을 보낸다(pw는 서버가 안보내게끔 만들었다고하자)<br>
```
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: id=hong123; expires=Wed, 12-Apr-2017 06:51:27 GMT; path=/
    Context-Length: 497

    <html>
    <head>
    <title>환영합니다~님</title>
```

3. 클라이언트는 해당사이트에대한 쿠키값을 세팅한다. id=hong123<br>
4. 클라이언트가 다시 해당사이트접속해서 요청하면 메시지가 아래처럼 쿠키가 세팅되서 같이보내진다.<br>
```
    GET /mypage.php HTTP/1.1
    Host: www.test.co.kr
    Cookie: id=hong123
```
5. 서버측에서는 클라이언트 메시지에 헤더에있는 쿠키값을 통해 사용자를 인식하게된다.
이 값으로 html에다가 식별하게 사용한다.<br>
```
<title>홍길동님의 페이지입니다</title> 
```

<h4>지속쿠키 폐기 과정</h4>
1. 로그아웃을 하면 클라이언트는 이렇게 메시지를 보낸다<br>

```
GET /logout.php HTTP/1.1
Host: www.test.co.kr
Cookie: id=hong123
```
2. 서버는 응답을 해준다.<br>
id를 지우겠다.
```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: id=deleted; expires=Tue, 12-Apr-2016 07:26:34 GMT; path=/
Context-Length: 497

<script>alert('로그아웃완료');location.href='index.php';</script>
```
3. 클라이언트 웹브라우저는 해당사이트에 대한 쿠키를(id=hong123) 메모리에서 지운다<br>

---
<h3>지속쿠기 문제점</h3>
쿠키를 폐기하여도 쿠키 값을 알고있으면 재사용이 가능하다. id=hong123이라고 다시보내면 서버는 set-cookie를 통해 응답을 하게된다<br>
그리고 쿠키값이 평문이면 변조의 위협이있다. id=admin으로 바꿔서 하면 관리자로 들어가는 위험이있다.<br>
그래서 반드시 암호화 과정이 있어야하고, 쿠키의 유효기간이 있어야한다.<br><br>

---
<h3>세션쿠키</h3>
서버에서 발급 시 클라이언트 웹 브라우저 캐시에 저장된다.<br>
1. 로그인

```
POST/login.php HTTP/1.1
Host: www.test.co.kr
Content-Type: application/x-www-form-urlencoded

id=hong123&pw=hong123!123!@
```

2. 서버에서는 아래처럼 세션에 해당하는 값들을 세팅할 수있다.<br>
2ef47012sa : ["id": "hong", ~] 
```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: PHPSESSID=2ef47012sa; path=/
Context-Length: 497

<html>
~
```

3. 클라이언트는 해당 쿠키값을 브라우저 캐시에 저장해놓고 페이지 요청마다 아래처럼 요청한다<br>

```
GET /mypage.php HTTP/1.1
Host: www.test.co.kr
Cookie: PHPSESSID=2ef47012sa
```

폐기과정은 지속쿠키는 사용자피시에 있는 쿠키값을 삭제했다고 하면 세션쿠키는 서버에있는 세션을 지운다.<br>
이렇게되면 폐기 후 재사용이 안되게된다.<br>

<h4>그러면 세션쿠키를 사용하면 되지. 왜 지속쿠키를 사용함?..</h4>
세션쿠키를 사용하면 보안 담당자, 개발자들이 편하긴하다. 그러나, 대규모 웹서비스의 경우 수많은 사용자들의<br>세션을 관리하기에는 엄청난 부하를 가져온다. - 메모리, 디비, 파일시스템에 세션을 저장하기에는 성능상 저하된다.<br>

----
웹브라우저 동작순서는 요청한 도메인 -> IP로 변환작업이 필요한데<br>
먼저<br> 
1. 로컬의 DNS캐시 확인(ipconfig 또는 displaydns) 
2. hosts 파일참조
3. DNS서버 질의
4. 로컬 DNS캐시에 저장된다.(재조회시에 쓰기위해)
5. HTTP요청 메시지 제작

HTTP프로토콜은 TCP/IP 통신을 기반으로 하기 때문에 3-way hand shake과정을 거친후 HTTP데이터를 전송한다<br>

<h3>ajax기술</h3>
ajax라는 기술로써 페이지 동기화(새로고침)필요없이 서버에 요청/응답을 받아 페이지 렌더링이 가능<br>
기존 웹 패러다임을 전환하는 기술이다.<br>
또한 백엔드측에 부하율을 낮출 수있다. 왜냐하면 페이지를 재호출해서 다시 구성하는게 아니라<br>
내가 필요한부분만 바꾸고 해당페이지는 그대로 두기 때문이다. 즉, 페이지자체를 재호출(css,jsp,js등)해서 재구성할필요가 없다는 뜻이다<br><br>

<h3>기본적으로 3-Tier구성이다. 웹-was-DB</h3>
웹은 정적처리: 이미지, 텍스트 등<br>
was는 동적: jsp 등 그래서 .do,jsp 등 를 호출하면 웹서버는 was로 포워딩하게 어딘가에 설정되있을것이다.<br><br>

<h3>WAS도 정적자원처리가능하다</h3>
localhost:8080치면 토끼이미지가 나오는거보면 정적자원도 처리가능하다<br>
근데, 웹서버는 정적자원처리가 효율적이기때문이다.<br>

---
<h3>웹구조는 크게 Server Side와 Client Side로 나뉜다</h3>
쉽게 Client-Side는 웹클라이언트에서 해석되는 HTML,CSS,JS를 의미 이러한스크립트를 Client-Side Script라고한다<br>
Server-Side는 웹어플리케이션서버에서 해석되는 PHP,JSP,ASP등을 의미하고 이러한것을 Server-Side Script라고한다.<br><br>

<h3>Client-Side Script기반 보안검증이 안전하지 않은이유</h3>
Client-Side Script 조작 및 값 변조가 가능하기떄문에 웹프록시도구로<br>
input 태그의 hidden타입의 전송도 웹프록시도구로 확인가능하기 때문에 반드시 서버측에서 보안 검증로직을 해야한다<br><br>

<h3>Client-side부분은 script 태그 부분이다.</h3>
<h3>Server-side부분은 ? 이부분이다. php이다</h3>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/7.PNG" width="650" height="400" /><br><br>

여기서 해석순서는 Server-side인 php를 먼저 해석하고 컴파일하고 Client-side를 해석한다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/8.PNG" width="650" height="400" /><br><br>
<h3>소스보기에서는 client-side는 그대로출력, server-side는 컴파일된 결과가 나온다.</h3>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/9.PNG" width="650" height="400" /><br>
웹서버에서는 server-side언어를 컴파일할수있으니 해석된상태로 소스보기처럼 나오고, client-side는 웹서버에서 해석못한다<br>
그렇기 떄문에 client-side는 마지막에 웹브라우저가 태그를 인식을해서 같이 마지막에 client-side먼저출력 하고 servier-side출력한다.<br><br>

그래서 server측에서 검증을 한번더 거치는 로직이 있어야한다.<br>

---
웹취약점진단이란 취약유/무에 대한 판단만 한다(체크리스트기반).<br>
모의해킹은 취약점이 발견될 경우 어떤 악의적인 영향이 나올지 (정보탈취를 통해서 어디까지 또~) 진단한다.<br><br>
취약점진단은 넓이 진단이라고 한다. 빠르게 판단하기위해 홈페이지 여러 메뉴에 대해 꼼꼼히 항목에 대해 테스트<br>
모의해킹은 깊이진단이라 한다. 여러메뉴에 대해 테스트하는게 중요한게 아니라 예를들어<br>
SQL인젝션 취약점이 나온다 하면 이 취약점을 통해 어떠한 행동까지 취할 수 있냐가 중요하다.<br>
대부분 파일취약점을 통해 시스템 명령어까지 실행할 수 있다.<br>
그래서 모의해킹 한두번하면 실력이 엄청 늘 수 있다.<br>

시나리오기반의 모의해킹업무는 시나리오,메뉴,계정을 받아서 진행<br>
블랙박스는 몰래 진행하거나,미션 진행, 깊게침투하기때문에 일정이 길다.<br>

---
#)mysql의 user테이블에 id가 user인 비밀번호 변경
> update mysql.user set password=password('hahaha') where user='root';

이후 flush previleges; 까지해줘야한다<br>

```
> create database example;
> use example; //db선택
> select database() // example출력이된다.(현재 데이터베이스)
> create table member(seq int, name char(20), email char(50));
> show tables;
> desc member; // 테이블명 구조를 보기위해
```
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/10.PNG" width="650" height="400" /><br><br>

---
```
> insert into member(seq,name,email) values(1,'administrator','admin@cre.or.kr');
> insert into member values(2,'test','test@cre.or.kr');
> update member set name='test1' where seq=6;
```

---
<h3>sql 연산자(!=,==,AND,OR,NOT,LIKE,WHERE 등)</h3>

```
5         +      3
피연산자 연산자  피연산자

XOR연산자는 피연산자1과 2중에서 오직하나만 참이면 참이다. 둘다참이면 거짓이다. 둘다거짓이면 거짓이다.

#)비트논리연산자 실습
> select 1&1; // 1
> select 2&1; // 0 (2를 이진수로 표현하면 00000010, 1은 00000001)
그래서 아래를 AND처리
00000010
00000001
--------
00000000 
따라서 0이나온다.

> select 5&3 //1
00000101
00000011
--------
00000001

> select 5|2  //7
00000101
00000010
--------
00000111
```
비트연산자가 왜필요하냐면 블라인드 베이스 공격에서 가장많이 사용되서 알아주면 좋다.<br>

---

```
#)연결연산자
mysql에서는 공백으로 문자열을 연결하고 반드시 문자열 두개가 피연산자여야한다.(concat과 비슷하다)
'te' 공백 'st'  //test
```

```
#)in연산자가 or쓰는거보다 빠르다.
> select name, email from member where id in('admin','guest'); //admin또는 guest 인거
```

```
#) %연산자
select * from member where email like '%@cre.or.kr';
```
---
#)문자열함수 SUBSTRING (문자열자를때)<br>
```
> select substring('test',1,1); //t
> select substring('test',3,1); //s
> select substring('test',3,2); //st
> select substr('test',3,2); //st
> select mid('test',3,2); //st
```

컴퓨터는 0,1만 인식하기때문에 a,b이런거는 모른다. 그래서 a,b라는 이진수값이 있어야한다<br>
이러한 형태들을 나타낸게 아스키코드이다. 총 7비트로 구성되어있고 128개의 문자코드가 있다.<br>
```
> select ascii('a'); //97 (십진수를 알수있다.)
> select bin(ascii('a')) //1100001 (이진수)
> select ascii(substring('test',1,1)) //116(이렇게 ascii와 substring을 혼합해서 많이쓴다)

아스키를 문자로 변환
> select char(97) //a
> select concat(char(97),char(97)) // aa
> select concat(char(97),char(100),char(109),char(105),char(110)) //admin
이렇게 싱글쿼터없이 admin이라는 단어를 출력했다.
```

#)count함수
```
> select count(*) from member //레코드 개수
```

#)길이함수
```
>select length('test'); //4
>select name, length(email) from member;
```
위와같은 임계값이(count,length)있어야 인젝션할 때 유용하다.<br>

