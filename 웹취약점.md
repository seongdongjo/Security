최초 웹은 팀 버너스 리 박사에 의해 탄생. 멀리떨어져있는 동료 연구자와 지식을 공유하기 위해 만듬<br>
그래서 초기의 웹은 단순히 텍스트로 구성되었으며, 하이퍼텍스트를 이용해 다른페이지로 이동하였다.<br>
1994~2004년까지가(텍스트+링크) 웹 1.0 시대라고 한다.<br><br>

URL에는 예약문자가 있는데 http:localhost:8080?val=test&val2=test+is<br>
여기서 ?,&,+이런게 예약문자이고 +는 공백을 의미한다. 서버에 넘어갈때는 test is 이렇게 파라미터 값으로 넘어간다.<br>

그러면 파라미터에 +같은 예약문자 자체를 못넘길까?? => 패스워드에 예약문자가 포함되어 파라미터로 던져야되는데..<br>

그때, 이제 URL인코딩을 쓴다. URL상에서 문자를 표현하는 방법으로 데이터 전송상에 손실을 막기위해서<br>
인코딩을 사용한다. 즉, 예약문자를 단순데이터로 전송이 될 수 있도록 인코딩을 한다.<br>
웹브라우저를 사용할 경우 브라우저에서 URL인코딩은 자동으로해준다.<br>

<h3>이정도는 외우자</h3>
문자    인코딩<br>
&       %26<br>
%       %25<br>
+       %2B<br>
공백    %20<br>
=       %3D<br>
#       %23<br>
'       %27<br>
?       %3F<br><br>

이런게 서버에 전달되면 알아서 각 문자로 바뀐다<br>
사용자입장에서는 어? 우리는 그냥 패스워드입력할때 특수문자 넣는데 누가 인코딩해주는거지?<br>
=>바로 웹브라우저에서 해준다. <br>
그래서 http://localhost:8080?pw=test%26%25 이렇게 나오는 것이다. <br>
<h4>즉, 클라이언트에서 서버로 갈때 인코딩을 해서 넘어간다.</h4>

HTTP프로토콜의 연결관리 방식은 크게 비지속연결과 지속연결 두가지로 나뉜다.<br>
HTTP버전에 따라 다른데, HTTP/0.9,1.0까지는 비지속연결이며, HTTP/1.0+,1.1,2.0은 지속연결이다<br>
HTTP1.0+에서 Keep-alive 커넥션을 통해 지속연결을 지원하며 HTTP/1.1부터는 명세에서 빠지고 지속연결을 기본으로한다<br>
즉, Keep-alive사용없이 모든연결을 지속연결로한다<br>

가끔 HTTP/1.1부터 keep-alive를 지원한다고 하는데 그거는 틀린것이다.<br>

---
<h4>비지속연결</h4>
초기에 HTTP에서 사용하던 방식이다.HTTP/1.0까지 사용되었다. <br>
초기웹은 단순히 문서를 전달했어서 지속연결이 필요하지않아서 한번의 요청이후 응답이 오면 끊어버렸다.<br>
하지만, 오늘날은 html뿐만아니라,js,css,png 등 많은 리소스가 필요한데 리소스요청마다 3-way hand shake를<br>
수행한다는것은 부적합한 연결방식이라는 것이다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/1.PNG" width="650" height="400" /><br><br>

---
<h4>지속연결</h4>
헤더에 "Connection: Keep-Alive"란 것이 명시가 되어있으면, 지속연결을 사용한다는 것이다.<br>
HTTP/1.0부터는 헤더에 "Connection: Keep-Alive"헤더 필요없이 기본적으로 지속연결을 한다.<br>
즉, 단 한번의 3-Way Handshake과정으로 여러번의 요청,응답을 할수 있다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/2.PNG" width="650" height="400" /><br><br>

---
<h4>HTTP메시지</h4>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/3.PNG" width="650" height="400" /><br><br>
헤더의 끝은 개행문자가 2개이다. 아래그림에 \r\n\r\n두개(개행문자)가 붙어있는걸 볼 수 있다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/4.PNG" width="650" height="400" /><br><br>
아래에 Content-Type까지가 헤더인데 두줄이 개행(\r\n\r\n)으로 띄워진걸 볼 수있다.<br>
또한, Post로 넘길때는 무조건 Content-Type: apllication/x-www-form-unlencoded 라고 있어야한다<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/4.PNG" width="650" height="400" /><br><br>
이렇게 에러페이지는 서버별로 다르기 때문에 어떤 서버를 쓰는지 확인할수있다.<br>
그래서 별도의 에러페이지를 만들어야 좋다.<br>
<img src="https://github.com/seongdongjo/Security/blob/main/웹취약점img/4.PNG" width="650" height="400" /><br><br>

---
쿠키: 지속쿠키, 세션쿠키로 나뉜다<br>
서버에서 클라이언트로 쿠키발급 시 Set-Cookie라는 헤더에 의해 클라이언트 쿠키값이 세팅하고,<br>
해당 사이트 접근 시마다 클라이언트는 Set-cookie에 의해 세팅된값을 Cookie헤더에 세팅하여 요청메시지를 전달한다.<br><br>

즉, 클라이언트가 A사이트 접속 시 A사이트의 서버는 Set-Cookie를 세팅해서 보내준다.<br>
그러면, 클라이언트측에서는 A사이트의 쿠키값을 기록해둔다.(웹브라우저 메모리에)<br>
이렇게 세팅이되면 A사이트 접근할때마다 상태관리를 하는것이다.<br>

<h4>지속쿠키 발급과정<h4>
- 로그인 기능으로 살펴보자<br>
1. 클라이언트가 로그인을 이렇게 요청했다고 하자<br>

```
POST/login.php HTTP/1.1
Host: www.test.co.kr
Content-Type: application/x-www-form-urlencoded

id=hong123&pw=hong123!123!@
```

2. 정상로그인이라면 서버는 아래처럼 응답을 보낸다(pw는 서버가 안보내게끔 만들었다고하자)<br>
```
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: id=hong123; expires=Wed, 12-Apr-2017 06:51:27 GMT; path=/
    Context-Length: 497

    <html>
    <head>
    <title>환영합니다~님</title>
```

3. 클라이언트는 해당사이트에대한 쿠키값을 세팅한다. id=hong123<br>
4. 클라이언트가 다시 해당사이트접속해서 요청하면 메시지가 아래처럼 쿠키가 세팅되서 같이보내진다.<br>
```
    GET /mypage.php HTTP/1.1
    Host: www.test.co.kr
    Cookie: id=hong123
```
5. 서버측에서는 클라이언트 메시지에 헤더에있는 쿠키값을 통해 사용자를 인식하게된다.
이 값으로 html에다가 식별하게 사용한다.<br>
```
<title>홍길동님의 페이지입니다</title> 
```

<h4>지속쿠키 폐기 과정</h4>
1. 로그아웃을 하면 클라이언트는 이렇게 메시지를 보낸다<br>

```
GET /logout.php HTTP/1.1
Host: www.test.co.kr
Cookie: id=hong123
```
2. 서버는 응답을 해준다.<br>
id를 지우겠다.
```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: id=deleted; expires=Tue, 12-Apr-2016 07:26:34 GMT; path=/
Context-Length: 497

<script>alert('로그아웃완료');location.href='index.php';</script>
```
3. 클라이언트 웹브라우저는 해당사이트에 대한 쿠키를(id=hong123) 메모리에서 지운다<br>

---
<h3>지속쿠기 문제점</h3>
쿠키를 폐기하여도 쿠키 값을 알고있으면 재사용이 가능하다. id=hong123이라고 다시보내면 서버는 set-cookie를 통해 응답을 하게된다<br>
그리고 쿠키값이 평문이면 변조의 위협이있다. id=admin으로 바꿔서 하면 관리자로 들어가는 위험이있다.<br>
그래서 반드시 암호화 과정이 있어야하고, 쿠키의 유효기간이 있어야한다.<br><br>

---
<h3>세션쿠키</h3>
서버에서 발급 시 클라이언트 웹 브라우저 캐시에 저장된다.<br>
1. 로그인

```
POST/login.php HTTP/1.1
Host: www.test.co.kr
Content-Type: application/x-www-form-urlencoded

id=hong123&pw=hong123!123!@
```

2. 서버에서는 아래처럼 세션에 해당하는 값들을 세팅할 수있다.<br>
2ef47012sa : ["id": "hong", ~] 
```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: PHPSESSID=2ef47012sa; path=/
Context-Length: 497

<html>
~
```

3. 클라이언트는 해당 쿠키값을 브라우저 캐시에 저장해놓고 페이지 요청마다 아래처럼 요청한다<br>

```
GET /mypage.php HTTP/1.1
Host: www.test.co.kr
Cookie: PHPSESSID=2ef47012sa
```

폐기과정은 지속쿠키는 사용자피시에 있는 쿠키값을 삭제했다고 하면 세션쿠키는 서버에있는 세션을 지운다.<br>
이렇게되면 폐기 후 재사용이 안되게된다.<br>

<h4>그러면 세션쿠키를 사용하면 되지. 왜 지속쿠키를 사용함?..</h4>
세션쿠키를 사용하면 보안 담당자, 개발자들이 편하긴하다. 그러나, 대규모 웹서비스의 경우 수많은 사용자들의<br>세션을 관리하기에는 엄청난 부하를 가져온다. - 메모리, 디비, 파일시스템에 세션을 저장하기에는 성능상 저하된다.<br>

----
웹브라우저 동작순서는 요청한 도메인 -> IP로 변환작업이 필요한데<br>
먼저<br> 
1. 로컬의 DNS캐시 확인(ipconfig 또는 displaydns) 
2. hosts 파일참조
3. DNS서버 질의
4. 로컬 DNS캐시에 저장된다.(재조회시에 쓰기위해)
5. HTTP요청 메시지 제작

HTTP프로토콜은 TCP/IP 통신을 기반으로 하기 때문에 3-way hand shake과정을 거친후 HTTP데이터를 전송한다<br>

<h3>ajax기술</h3>
ajax라는 기술로써 페이지 동기화(새로고침)필요없이 서버에 요청/응답을 받아 페이지 렌더링이 가능<br>
기존 웹 패러다임을 전환하는 기술이다.<br>
또한 백엔드측에 부하율을 낮출 수있다. 왜냐하면 페이지를 재호출해서 다시 구성하는게 아니라<br>
내가 필요한부분만 바꾸고 해당페이지는 그대로 두기 때문이다. 즉, 페이지자체를 재호출(css,jsp,js등)해서 재구성할필요가 없다는 뜻이다<br><br>

<h3>기본적으로 3-Tier구성이다. 웹-was-DB</h3>
웹은 정적처리: 이미지, 텍스트 등<br>
was는 동적: jsp 등 그래서 .do를 호출하면 웹서버는 was로 포워딩하게 어딘가에 설정되있을것이다.<br>






