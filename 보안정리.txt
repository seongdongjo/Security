#)클릭제킹 : 사용자의 클릭이 의도하지 않은 화면을 클릭하게 해서 사용자의 의도와 다른 이벤트를 발생
- 예를들어 광고레이어를 투명하게 만들어서 안보이게하고 클릭하면 광고페이지로 이동
//web.xml에 추가해서 해결
<filter>
        <filter-name>httpHeaderSecurity</filter-name>
        <filter-class>org.apache.catalina.filters.HttpHeaderSecurityFilter</filter-class>
        <init-param>
            <param-name>antiClickJackingOption</param-name>
            <param-value>SAMEORIGIN</param-value>
        </init-param>
    </filter>
-------------
#)CSRF 공격(Cross Site Request Forgery)은 인터넷사용자(희생자!!)가 자신의 의지와는 무관하게 공격자가 의도한대로(수정,삭제 등) 특정 웹사이트에
요청하게 만드는 공격이다. 즉, CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능하다.
CSRF는 해커가 사용자의 컴퓨터를 감염시키거나 페이스북 서버를 해킹을 해서 이뤄지는 공격이 아니다.

#)XSS와 CSRF의 차이
XSS는 공격대상이 Client이고 CSRF는 Server이다.

#)XSS와 CSRF의 공통점
둘다 스크립트 공격이다.

XSS는 사용자가 특정웹사이트를 신용하는 점을 노림
CSRF는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 것을 노림

XSS는 사이트변조나 백도어를 통해 클라이언트에 대한 공격을한다.
CSRF는 요청을 위조하여 사용자의 권한을 이용해 서버에 대한 공격을한다.

CSRF는 일단 사용자가 웹사이트에 로그인한 상태에서 공격자가 등록한 조작된 요청정보를 담고있는 게시물을 열면
해당 웹사이트는 위조된 공격명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 피해를 입는다.

XSS는 희생자 클라이언트 PC에서 실행되며 사용자의 정보를 탈취하는 것이고, CSRF는 위조된 요청을 서버에 보내어 서버단에서 스크립트가 실행됩니다.

XSS는
1. 취약점을 찾아서 세션 쿠키를 탈취하는 스크립트를 사이트에 삽입합니다.

2. 사용자가 그 웹사이트에 접근할 때마다 스크립트가 작동합니다

3. 스크립트를 통해 침입자에게 사용자의 세션 쿠키가 전달됩니다.
input 박스에 사용자가 <script>hello</script> 이렇게
그래서, 스크립트 태그를 필터링 할 필요가 있다. <는 &lt; 등으로 필터링을하면 
사용자에게는 <script>로 보이지만 실제는 &lt;script&gt; 로 브라우저에서는 일반문자로 인식되서 스크립트가 실행되지 않는다.


CSRF는
1. 침입자는 하이퍼링크에 자금 전송 요청에 대한 스크립트를 삽입하고 사이트에 로그인할 사람들에게 전송합니다.

2. 사용자는 링크를 누르고(외부링크), 의도치않게 서버로 요청을 보내게 됩니다.

3. 서버는 로그인 되어있는 사용자의 요청이기 떄문에 정상으로 인식하고 침입자에게 돈을 전송합니다.

CSRF는 사용자의 권한을 이용하여 게시물 작성에 <html> ~~<html> 이렇게 작성하는 방법과(기존 form id,value를 분석해서)
또는 공격자가 만든 사이트 링크를 보내서 공격하는 방법이있다.

GET을 이용한 공격방법(URL방법)
A라는 사이트에 비밀번호변경페이지에서 입력란이 NewPassword, Confirm Password만 있을경우 (기존비밀번호는 입력안할때)
만약에 A라는 사이트의 사용자 비밀번호 변경!!!!을 하는 경우 주소패턴이 abc.com/user.do?cmd=user_passwd_change&user=admin&newPwd=1234
라고하면 이러한링크를 사용자의 메일로보내서 읽게되면 비밀번호가 바뀐다.(관리자계정으로 로그인되있으면 관리자계정 비밀번호를 바꿀수있다) 
그래서 비밀번호 변경시에는 공격자가 기존 비밀번호를 모르기때문에 기존비밀번호입력란을 만들어서 공격을 방지할 수 있다.

POST를 이용한 공격방법(Form이용)
기존의 비밀번호 변경하는 페이지가 위에처럼 New, Confirm만 있다고 가정하에 그럼 form에 new, confirm 패스워드만 몰래 넣어서 action을 비밀번호 변경.do로 가면 변경이된다.
그래서 공격자는 form태그로 만든 게시물을 올려서(이것도 XSS취약점) 게시물을 사용자가 클릭하면 해당 계정은 비밀번호가 변경되는 것이다. -> 자동스크립트로인해
<script>
	document.forms[0].submit();
</script>



-------------
#)Application error disclosure(탐지된 오류 노출)
400(Bad Request), 401(Authorization Required), 403(Forbidden), 404(Not Found), 500(Internal Server Error) 등과 같이
웹 서버에서 오류가 발생할 경우 이에 대한 상세한 정보가 노출되는 경우에 탐지된다.

웹 브라우저에 에러페이지 뜨면서 톰캣버전, stacktrace를 통해 서비스의 내부 구조를 파악할 수 있다.

-------------
#)Directory Browsing(디렉토리 나열) 취약점
직접적인 공격 방법은 아니나 디렉토리 내의 파일목록을 노출시킴으로써 서비스 운영자가 노출을 원하지 않았던
파일들이 노출되고 서비스 구조파악에 도움을 줌으로써 공격에 도움이 될 수 있다.
디렉토리 나열 취약점으로 탐지된 URL을 웹 브라우저로 접속을 하면 디렉토리 구조가 보인다.

--------------
#)Session은 브라우저당 한개이다.(크롬,엣지 등)

예를들어 F12에서 보이는 JSession이다. 디버그를 돌리면 Session안에 Attributes 라는게 있다. 
거기서 CSRF_TOKEN을 key:value로 안에 쏙 넣은것이다.
즉 Session(4CDF~) { CSRF_TOKEN=5c~~, loginVO=~   }

if(request.getSession().getAttribute("CSRF_TOKEN").equals(param)) {
				
			}
if(param == null) {
		HttpSession session = request.getSession();
		session.setAttribute("CSRF_TOKEN", UUID.randomUUID().toString());
}


=============================================================================================




